<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ソースコード内解答 一括Base64変換ツール</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans CJK JP", "Yu Gothic", sans-serif; line-height: 1.7; max-width: 1000px; margin: 20px auto; padding: 0 20px; background-color: #f4f7f9; }
        .container { background-color: #fff; padding: 2em; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 small { font-size: 0.5em; color: #777; }
        label { font-weight: bold; display: block; margin-top: 1.5em; margin-bottom: 0.5em; }
        textarea, input[type="text"] { width: 98%; padding: 1%; font-size: 1em; font-family: Consolas, "Courier New", monospace; border-radius: 4px; border: 1px solid #ccc; resize: vertical; }
        .buttons { margin-top: 1em; display: flex; gap: 10px; }
        button { font-size: 1.1em; padding: 10px 20px; border: none; color: white; border-radius: 5px; cursor: pointer; flex-grow: 1; }
        button:hover { opacity: 0.9; }
        #encodeBtn { background-color: #007bff; }
        #decodeBtn { background-color: #6c757d; }
        #status { padding: 10px 15px; background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; margin-top: 1em; word-wrap: break-word; min-height: 1.5em; }
        code { background-color: #eee; padding: 2px 5px; border-radius: 3px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ソースコード内解答 一括Base64変換ツール <small>(v2.4)</small></h1>
        <p>
            教材のソースコードを貼り付けて「エンコード実行」または「デコード実行」ボタンを押してください。<br>
            内部の<code>#pb</code>と<code>##pb</code>と<code>#wt</code>コマンドの解答/パスワード部分を自動で変換します。
        </p>

        <div>
            <label for="prefixInput">プレフィックス（魔法の文字列）:</label>
            <input type="text" id="prefixInput" value="0000">
        </div>

        <div>
            <label for="inputSource">1. ソースコードを入力:</label>
            <textarea id="inputSource" rows="15" placeholder="ここにpreタグの中身を貼り付け..."></textarea>
        </div>

        <div class="buttons">
            <button id="encodeBtn" onclick="processSourceText('encode')">エンコード実行</button>
            <button id="decodeBtn" onclick="processSourceText('decode')">デコード実行</button>
        </div>

        <div>
            <label for="outputSource">2. 変換後のソースコード:</label>
            <textarea id="outputSource" rows="15" readonly></textarea>
        </div>

        <div id="status"></div>
    </div>

    <script>
        const inputEl = document.getElementById('inputSource');
        const outputEl = document.getElementById('outputSource');
        const statusEl = document.getElementById('status');
        const prefixInputEl = document.getElementById('prefixInput');

        /**
         * A generic function to process the source text for encoding or decoding.
         * @param {'encode' | 'decode'} mode - The operation mode.
         */
        function processSourceText(mode)
        {
            const MAGIC_PREFIX = prefixInputEl.value;
            if (MAGIC_PREFIX.trim() === '')
            {
                statusEl.textContent = '❌ プレフィックスが空です。変換を中止しました。';
                statusEl.style.color = '#dc3545';
                return;
            }

            const inputText = inputEl.value;
            const lines = inputText.split('\n');
            let convertedCount = 0;

            const processedLines = lines.map(line =>
            {
                const trimmedLine = line.trim();
                const args = parseCommandAndArguments(trimmedLine);
                if (!args) { return line; }

                const command = args[0];
                const isPb = ((command === '#pb' || command === '##pb') && args.length >= 4);
                const isWt = (command === '#wt' && args.length >= 4);

                if (isPb || isWt)
                {
                    const answers = args[3];
                    if (answers.trim() === '') { return line; }

                    let newAnswers = '';
                    if (mode === 'encode')
                    {
                        // --- ENCODING LOGIC ---
                        try
                        {
                            const firstPart = answers.split(',')[0].trim();
                            if (firstPart && atob(firstPart).startsWith(MAGIC_PREFIX)) { return line; }
                        }
                        catch (e) { /* Not our format, so we can encode */ }
                        
                        newAnswers = answers.split(',')
                            .map(part => {
                                const trimmed = part.trim();
                                if (!trimmed) return '';
                                const prefixed = MAGIC_PREFIX + trimmed;
                                return btoa(unescape(encodeURIComponent(prefixed)));
                            })
                            .join(',');
                    }
                    else // mode === 'decode'
                    {
                        // --- DECODING LOGIC ---
                        newAnswers = answers.split(',')
                            .map(part => {
                                const trimmed = part.trim();
                                if (!trimmed) return '';
                                try {
                                    const decoded = decodeURIComponent(escape(atob(trimmed)));
                                    return decoded.startsWith(MAGIC_PREFIX) ? decoded.substring(MAGIC_PREFIX.length) : trimmed;
                                } catch (e) {
                                    return trimmed; // If it's not valid Base64, return it as is.
                                }
                            })
                            .join(',');
                    }

                    if (answers !== newAnswers)
                    {
                        convertedCount++;
                        const lastBraceIndex = trimmedLine.lastIndexOf('{');
                        const lineStart = trimmedLine.substring(0, lastBraceIndex + 1);
                        const indentation = line.match(/^\s*/)[0];
                        return indentation + lineStart + newAnswers + '}';
                    }
                }
                return line;
            });

            outputEl.value = processedLines.join('\n');
            
            const actionText = mode === 'encode' ? 'エンコード' : 'デコード';
            if (convertedCount > 0)
            {
                statusEl.textContent = `✅ ${convertedCount} 個のコマンドの解答/パスワードを${actionText}しました。`;
                statusEl.style.color = '#28a745';
            }
            else
            {
                statusEl.textContent = `ℹ️ ${actionText}対象の #pb , ##pb または #wt コマンドが見つかりませんでした。`;
                statusEl.style.color = '#17a2b8';
            }
        }
        
        // parser function (no changes)
        function parseCommandAndArguments(textLine) {
            const commandMatch = textLine.match(/^([#]{1,3}(?={)|([#@][a-zA-Z0-9_-]+))\s*/);
            if (!commandMatch) { return null; }
            const command = commandMatch[1];
            const argsArray = [command];
            let currentPos = commandMatch[0].length;
            while (currentPos < textLine.length) {
                if (textLine[currentPos] !== '{') {
                    if (argsArray.length === 1 && textLine.substring(currentPos).trim() === "") { return argsArray; }
                    break;
                }
                currentPos++;
                let argumentContent = "";
                let braceLevel = 1;
                const argumentStartPos = currentPos;
                while (currentPos < textLine.length) {
                    const char = textLine[currentPos];
                    if (char === '{') braceLevel++;
                    else if (char === '}') braceLevel--;
                    if (braceLevel === 0) {
                        argumentContent = textLine.substring(argumentStartPos, currentPos);
                        argsArray.push(argumentContent);
                        currentPos++;
                        break;
                    }
                    currentPos++;
                }
                if (braceLevel !== 0) { return null; }
            }
            return argsArray;
        }
    </script>

</body>
</html>